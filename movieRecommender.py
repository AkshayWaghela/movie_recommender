# -*- coding: utf-8 -*-
"""Untitled7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xyzznfq5FoHyk5qXarmqSX4vQs7lPoVB
"""


import numpy as np
import pandas as pd


# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.
# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save & Run All"
# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session



import pandas as pd
import pandas as pd
import streamlit as st

@st.cache_data
def load_data():
    url = "https://raw.githubusercontent.com/AkshayWaghela/movie_recommender/main/movies.csv"
    return pd.read_csv(url)

a = load_data()





a.info()




hindi = a.copy()


hindi.head()

hindi.describe(include='all').T

hindi.info()

# List of all unique languages sorted alphabetically
languages = sorted(a['original_language'].dropna().unique())

hindi.isnull().sum().sort_values(ascending=False)

hindi[['title','release_date', 'popularity', 'vote_average', 'vote_count']].sort_values(by='popularity', ascending=False).head(10)

# Convert to datetime if not already
hindi['release_date'] = pd.to_datetime(hindi['release_date'], errors='coerce')
hindi['release_year'] = hindi['release_date'].dt.year


# app.py

import pandas as pd
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import streamlit as st

# -----------------------------
# Load Dataset
# -----------------------------
df = hindi # pd.read_csv("movies.csv")  # must contain 'title', 'overview', 'genres', 'cast', 'director', 'imdb_rating', 'poster_path'

# Build combined feature for cosine similarity
df['combined'] = (
    df['overview'].fillna('') + " " +
    df['genres'].fillna('') + " " +
    df['cast'].fillna('') + " " +
    df['director'].fillna('')
)

# TF-IDF + cosine similarity
tfidf = TfidfVectorizer(stop_words="english")
tfidf_matrix = tfidf.fit_transform(df['combined'])
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

# TMDB Poster Base URL
POSTER_BASE = "https://image.tmdb.org/t/p/original"

# -----------------------------
# Recommendation Function
# -----------------------------
def recommend(movie_title, user_rating, top_n=5):
    try:
        idx = df[df['title'].str.lower() == movie_title.lower()].index[0]
    except:
        return []

    # similarity scores
    sim_scores = list(enumerate(cosine_sim[idx]))
    recs = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:top_n*3]

    # candidate movies
    candidates = [(i, score, df.iloc[i]['title'], df.iloc[i]['imdb_rating'], df.iloc[i]['poster_path'])
                  for i, score in recs]

    # logic based on user rating
    if user_rating < 6:
        candidates = sorted(candidates, key=lambda x: (x[3], x[1]), reverse=True)
    else:
        candidates = sorted(candidates, key=lambda x: (x[1], x[3]), reverse=True)

    results = [{
        "title": title,
        "imdb": imdb,
        "score": round(score, 3),
        "poster": f"{POSTER_BASE}{poster}" if isinstance(poster, str) else None
    } for _, score, title, imdb, poster in candidates[:top_n]]

    return results

# -----------------------------
# User Profile Storage (Session-based)
# -----------------------------
if "history" not in st.session_state:
    st.session_state["history"] = []  # [(movie, rating, chosen_from_recs)]

# -----------------------------
# Streamlit UI
# -----------------------------
st.title("🎬 Smart Movie Recommender")
st.write("Tell us the last movie you watched and your rating. We'll suggest what to watch next!")

movie_input = st.text_input("Enter the last movie you watched:")
user_rating = st.slider("Your rating (1–10)", 1, 10, 7)

if st.button("Recommend"):
    if movie_input:
        recs = recommend(movie_input, user_rating, top_n=5)
        if recs:
            st.subheader("Recommendations for you:")

            # Display recommendations in columns
            cols = st.columns(len(recs))
            chosen_movie = None

            for i, rec in enumerate(recs):
                with cols[i]:
                    if rec["poster"]:
                        st.image(rec["poster"], use_container_width=True)
                    st.write(f"**{rec['title']}**")
                    st.write(f"IMDb ⭐ {rec['imdb']} | Score: {rec['score']}")
                    if st.button(f"🎥 Watch this", key=f"watch_{i}"):
                        chosen_movie = rec["title"]

            if chosen_movie:
                st.session_state["history"].append((movie_input, user_rating, chosen_movie))
                st.success(f"You chose to watch **{chosen_movie}** 🎉")
        else:
            st.error("Movie not found in database.")
    else:
        st.warning("Please enter a movie name.")

# -----------------------------
# User History
# -----------------------------
if st.session_state["history"]:
    st.subheader("📖 Your Watch History")
    for entry in st.session_state["history"]:
        st.write(f"- Watched: *{entry[0]}* (you rated {entry[1]}) → Next: *{entry[2]}*")
